function [] = detect_capillaries(image_path, varargin)
%DETECT_CAPILLARIES *Insert a one line summary here*
%   [] = detect_capillaries(varargin)
%
% DETECT_CAPILLARIES uses the U_PACKARGS interface function
% and so arguments to the function may be passed as name-value pairs
% or as a struct with fields with corresponding names. The field names
% are defined as:
%
% Mandatory Arguments:
%
% Optional Arguments:
%
% Outputs:
%
% Example:
%
% Notes:
%
% See also:
%
% Created: 14-Mar-2013
% Author: Michael Berks 
% Email : michael.berks@manchester.ac.uk 
% Phone : +44 (0)161 275 7669 
% Copyright: (C) University of Manchester 

% Unpack the arguments:
args = u_packargs(varargin, '0', ...
    'border_width', 32,...
    'exclusion_zone', 32,...
    'apex_class_thresh', 0.5,...
    'offset_votes_thresh', 0,...
    'max_num_candidates', 100,...
    'thetas', linspace(-pi/8, pi/8, 20),...
    'scales', [0.8 0.9 1.0 1.1 1.2],...
    'mean_shape_path', [],...
    'aam_dir', [],...
    'aam_exe', 'ncm_sandpit_mb',...
    'aam_path', '',...
    'vessel_probs', [],...
    'g2d_sigma', 4, ...
    'g2d_vals', [],...
    'prob_thresh', 0.9,...
    'distal_angle', pi/4, ...
    'do_template_matching', 0,...
    'do_aam', 0, ...
    'do_final_vessel', 0, ...
    'delete_candidate_patches', 0,...
    'nailfold_mask', []);
clear varargin;

%Load in nailfold
nailfold = imread(image_path);   
nailfold = nailfold(:,:,1);

%Make a mask for the nailfold if one hasn't been supplied
if ~isempty(args.nailfold_mask)
    nailfold_mask = args.nailfold_mask;
    args = rmfield(args, 'nailfold_mask');
else
    nailfold_mask = make_nailfold_mosaic_mask(nailfold);
end

%--------------------------------------------------------------------------
rf_ori = u_load('C:\isbe\nailfold\models\vessel\orientation\rf_regression\259076\predictor.mat');
rf_ori.tree_root = 'C:\isbe\nailfold\models\vessel\orientation\rf_regression/';
ori_args = u_load('C:\isbe\nailfold\models\vessel\orientation\rf_regression\259076\job_args.mat');

rf_det = u_load('C:\isbe\nailfold\models\vessel\detection\rf_classification\257273\predictor.mat');
rf_det.tree_root = 'C:\isbe\nailfold\models\vessel\detection\rf_classification/';
det_args = u_load('C:\isbe\nailfold\models\vessel\detection\rf_classification\257273\job_args.mat');

rf_wid = u_load('C:\isbe\nailfold\models\vessel\width\rf_regression\257847\predictor.mat');
rf_wid.tree_root = 'C:\isbe\nailfold\models\vessel\width\rf_regression/';
wid_args = u_load('C:\isbe\nailfold\models\vessel\width\rf_regression\257847\job_args.mat');

warning('off', 'ASYM:unexpectedArgument');

[vessel_ori] = predict_image(...
    'image_in', vessel_patch,...
    'mask', nailfold_mask,...
    'decomposition_args', ori_args.decomposition_args,...
    'predictor', rf_ori, ...
    'prediction_type', 'rf_regression',...
    'output_type', 'orientation');
%
[vessel_prob] = predict_image(...
    'image_in', vessel_patch,...
    'mask', nailfold_mask,...
    'decomposition_args', det_args.decomposition_args,...
    'predictor', rf_det, ...
    'prediction_type', 'rf_classification',...
    'output_type', 'detection',...
    'use_probs', 1);
%
[vessel_width] = predict_image(...
    'image_in', vessel_patch,...
    'mask', nailfold_mask,...
    'decomposition_args', wid_args.decomposition_args,...
    'predictor', rf_wid, ...
    'prediction_type', 'rf_regression',...
    'output_type', 'width');

[vessel_centre, vessel_prob, vessel_ori, vessel_width] =...
    extract_vessel_centres(vessel_prob, vessel_ori, vessel_width);

[~, vessel_centre] = discard_edge_preds(vessel_centre, nailfold_mask, args.border_width);

%--------------------------------------------------------------------------
hog_args.cell_sz = [8 8];
hog_args.num_ori_bins = 9;

[apex_offset_map] = ...
        predict_apex_offsets(...
            'apex_class_rf', apex_class_rf,...
            'apex_offset_x_rf', apex_offset_x_rf,...
            'apex_offset_y_rf', apex_offset_y_rf,...
            'vessel_feature_im', vessel_prob, ...
            'vessel_centre', vessel_centre, ...
            'smoothing_sigma', 0,...
            'num_cells', 8,...
            'hog_args', hog_args,...
            'apex_class_thresh', apex_class_thresh);
        
[candidate_xy candidate_scores] = ...
    local_image_maxima(apex_offset_map, args.exclusion_zone, nailfold_mask, args.offset_votes_thresh);

%Select candidates somehow spatially

%--------------------------------------------------------------------------
if args.do_aam
    mean_shape = u_load(args.mean_shape_path);
    
    initialise_aam_candidates(image_path, vessel_width, vessel_ori, candidate_xy, ...
        'aam_dir', [aam_dir im_num '/'],...
        'mean_shape', mean_shape,...
        'base_width', 15,...
        'width_sigma', 0,...
        'ori_sigma', 0,...
        'max_num_candidates', args.max_num_candidates,...
        'thetas', args.thetas,...
        'scales', args.scales,...
        'debug', 0);
    
    fit_aam_to_candidates(...
        'aam_dir', [aam_dir im_num '/'],...
        'aam_exe', 'ncm_sandpit_mb',...
        'aam_path', [args.model_dir args.aam_name],...
        'delete_candidate_patches', args.delete_candidate_patches);
end
        
%--------------------------------------------------------------------------        
if do_other_stuff
    num_candidates = length(dir([args.aam_dir 'apex*_aam.mat']));
    for i_ap = 1:num_candidates

        %Load in apex structure
        load([args.aam_dir 'apex' zerostr(i_ap, 4) '_aam.mat'], 'apex_candidate');

        %Get patch from vessel_probs
        vessel_probs_patch = vessel_probs(...
            apex_candidate.sr:apex_candidate.er,...
            apex_candidate.sc:apex_candidate.ec);

        %Get vessels connected to the fitted apex
        apex_x = apex_candidate.fitted_vessel_xy(:,1);
        apex_y = apex_candidate.fitted_vessel_xy(:,2);
        vessel_i = bwselect(vessel_probs_patch > args.prob_thresh, apex_x , apex_y);

        if ~any(vessel_i(:))
            continue;
        end

        %Thin to get the centreline
        vessel_is = bwmorph(vessel_i, 'thin', inf);
        [skel_y skel_x] = find(vessel_is);

        %Use distance transform to compute width of vessel at each centre pixel
        width_map = bwdist(~vessel_i);
        skel_widths = width_map(vessel_is)*2 - 1;

        %Now project each fitted apex point to the centreline
        num_pts = length(apex_x);
        apex_widths = zeros(num_pts,1);
        apex_skel_x = zeros(num_pts,1);
        apex_skel_y = zeros(num_pts,1);
        for i_p = 1:num_pts
            [~, min_idx] = min((skel_x-apex_x(i_p)).^2 + (skel_y-apex_y(i_p)).^2);
            apex_widths(i_p) = skel_widths(min_idx);
            apex_skel_x(i_p) = skel_x(min_idx);
            apex_skel_y(i_p) = skel_y(min_idx);
        end
        apex_candidate.mean_apex_widths = mean(apex_widths);


        %Final vessel
        [vessel_y vessel_x] = find(vessel_i);
        apex_candidate.final_vessel = [vessel_x, vessel_y];

        centre_pt = (num_pts-1) / 2;
        global_x = apex_candidate.sc+apex_x(centre_pt);
        global_y = apex_candidate.sr+apex_y(centre_pt);
        if ~exist('distal_apexes', 'var');
            distal_apexes = [global_x global_y];
            apex_candidate.is_distal = true;
        else
            tan_vectors = abs(atan(...
                (distal_apexes(:,2)-global_y) ./...
                (distal_apexes(:,1)-global_x)));

            apex_candidate.is_distal = all(tan_vectors < args.distal_angle);
            if apex_candidate.is_distal
                distal_apexes = [distal_apexes; global_x global_y]; %#ok
            end
        end          
        save([args.aam_dir 'apex' zerostr(i_ap, 4) '_aam.mat'], 'apex_candidate');

    end
end
%--------------------------------------------------------------------------
%End of main function
%--------------------------------------------------------------------------

