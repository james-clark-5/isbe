function [y_out y_trees proximities] = random_forest_reg_predict(forest, X, is_orientation, tree_mask, rand_sample)
%RANDOM_FOREST_CLASS_PREDICT given a random forest and input data,
%predict the set of class labels for the data
%   [random_forest] = random_forest_class_predict(forest, X)
%
%   X:      N x d matrix of input data, where each row is a
%           datapoint consisting of d input variables
%
%   forest: Random forest structure as generated by
%   RANDOM_FOREST_CLASS_TRAIN
%
% Outputs:
%   ori_fit:  Predictions of orientation for each input sample in X,
%           represented as a complex number. The arg of which gives the
%           orientation, the magnitude gives a measure of how consistent
%           the predictions were from each tree, and thus a measure of
%           confidence in the prediction
%
%
% Example:
%
% Notes:
%
% See also: RANDOM_FOREST_CLASS_TRAIN TREE_PREDICT
%
% Created: 13-Oct-2009
% Author: Michael Berks 
% Email : michael.berks@postgrad.man.ac.uk 
% Phone : +44 (0)161 275 1241 
% Copyright: (C) University of Manchester 
if nargin < 3
    is_orientation = 0;
end
if nargin < 4
    tree_mask = [];
end
if nargin < 5
    rand_sample = 0;
end

%workout number of data points and input variables
N = size(X, 1);

%Work out number of trees in forest and number of output classes
ntrees = length(forest.trees);
    
%pre-allocate space tree regression values
y_trees = zeros(N, ntrees);

if nargout > 2
    proximities = zeros(N);
end

%Check if trees are preloaded
if isstruct(forest.trees{1})
    trees_loaded = true;
elseif ischar(forest.trees{1})
    trees_loaded = false;
else
    error(['Incorrect datatype for trees. Must either be a struct containing the tree itself',...
        ' or a string containg the filepath to the tree on disk']);
end

for ii = 1:ntrees

    %load tree
    if trees_loaded
        tree = forest.trees{ii};
    else
        tree = u_load([forest.tree_root forest.tree_dir forest.trees{ii}]);
    end
    
    %Get predictions for data from this tree
    [y_tree nodes] = tree_predict(tree, X);
    y_trees(:,ii) = y_tree;
    
    if nargout > 2
    %Compute proximity measure - i.e. count the number of times data points
    %end up at the same leaf node
        leaf_nodes = unique(nodes);
        for jj = 1:length(leaf_nodes)
            leaf = leaf_nodes(jj);
            leaf_pts = double(nodes == leaf);
            proximities = proximities + (leaf_pts * leaf_pts');
        end
    end   
end

%If we're supplied with a tree mask, set to NaN any masked out values (e.g. used
%to compute out-of-bag errors on training data)
if ~isempty(tree_mask)
    y_trees(tree_mask) = NaN;
end

if is_orientation
    if isreal(y_trees)
        %Assume orientations (stored in y_trees) are in degrees in the range, 0-180
        %we need to double this and map to radians to compute the mean
        y_trees = pi*y_trees/90; %[0, 2pi]

        %Viewing the orientation returned by each tree as a unit vector, work out 
        % the mean vector for each sample
        u_mean = naNmean(cos(y_trees),2);
        v_mean = naNmean(sin(y_trees),2);

        %Workout the magnitude and arg of the mean vectors
        r_out = sqrt(u_mean.^2 + v_mean.^2);
        theta_out = atan2(v_mean, u_mean);
    else
        if rand_sample
            %Randomly samples from tree predictions weighted by dispersion
            %magnitude

            %Compute magnitudes of each tree prediction
            uv_abs = abs(y_trees);

            %Compute cumulative sum scaled from 0 to 1
            col_probs = bsxfun(@rdivide, cumsum(uv_abs,2), sum(uv_abs,2));

            %Generate switching matrix with a 1 in each row, where the column
            %is randomly selected weighted by magntiude
            rand_cols = sum(bsxfun(@le, col_probs, rand(N,1)),2)+1;
            rand_idx = sub2ind([N ntrees], (1:N)', rand_cols);

            %Use swicthing matrix to get magntiude and arg angle of selected
            %predictions
            %r_out = uv_abs(rand_idx);
            r_out = naNmean(uv_abs, 2);
            theta_out = angle(y_trees(rand_idx));
        else
            %Take mean over all complex predictions
            uv_mean = naNmean(y_trees, 2);
            r_out = abs(uv_mean);
            theta_out = angle(uv_mean);
        end

    end

    %Combine the mag and halve the arg into a new complex array
    %ori_fit = r_out .* exp(i*theta_out/2);
    y_out = r_out .* exp(1i*theta_out);
else
    if rand_sample
        %TO DO: sleect random sample of non-circular input (based on var?)
    else
        y_out = naNmean(y_trees, 2);
    end
end

%If we need to calculate proximities, divide by ntrees to get measure
%between 0 and 1
if nargout > 2
    proximities = proximities / ntrees;
end